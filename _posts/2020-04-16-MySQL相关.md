---
layout:     post
title:      MySQL相关
subtitle:   MySQL相关
date:       2020-04-16
author:     pengfeng
header-img: img/post-bg-rwd.jpg
catalog: true
tags:
    - java
    - mysql
---

#### **MySQL学习笔记**

>目录
* [存储引擎](#1)
* [索引](#2)
* [事务](#3)
* [锁](#4)
* [表优化](#5)
* [连接池](#6)

>正文

#### 1、索引

MySQL索引使用的数据结构主要是BTree索引和哈希索引,哈希索引底层是哈希表,在单表查询的时候性能快,所以一般场景下还是使用BTree的居多。InnoDB和MyISAM是基于B树的B+树实现的,只是其中的实现方式不同.

* **聚簇索引**:每个表都会有一个聚簇索引 一般是主键,如果没有第一个not NULL unique列是聚集索引,否则，InnoDB会创建一个隐藏的row-id作为聚集索引
聚簇索引的B+树叶子节点上存的是索引和数据本身,当查询时可以通过查找叶子节点上的索引直接找到数据,所以性能很高。

* **非聚簇索引**: 理解为辅助索引,B+树节点上存的是索引,查询时先通过叶子节点上的索引找到记录的主键值,再通过主键索引找到对应的记录,这样的操作也叫回表。

>如何避免回表?

常见的方法是：将被查询的字段，建立到联合索引里去。

#### 2、存储引擎

**InnoDB**:  
支持事务,行锁表锁,默认是行锁,支持MVCC只在读已提交,可重复读的隔离级别才会生效

**MyISAM**
不支持事务,查询具有原子性,执行速度比InnoDB快,但是数据丢失无法找回


#### 3、事务

>ACID原则

* **原子性**:事务最小单位,要么成功,要么失败
* **一致性**:事务开启前和事务开启后,多个事务查询结果一致
* **隔离性**:事务与事务之间独立,并发事务之间数据库独立
* **持久性**:事务提交之后,对数据的修改是永久的,不会私自改变

>事务带来的问题

脏读,幻读,不重复读,丢失修改

* **脏读**: 取钱场景,事务对钱修改了,没提交,读的是老数据
* **幻读**: 前一个事务查询5条记录,后一个事务插入2条,一个事务里两次查询的条数不一致
* **不可重复度**:一次事务两次查询记录不一样
* **丢失修改**:两个事务修改同一条记录,前面一个事务的修改被覆盖

>隔离级别

* **读已提交** 防止脏读,可能产生幻读,不可重复读
* **读未提交** 最低的级别,会导致幻读,脏读,不可重复读
* **可重复读** 可能幻读,能预防脏读,不可重复读
* **可串行话** 最高级别,事务之间完全隔离,采用快照版本防止,效率低下

#### 4、锁

* **行锁**: 当我们对一行进行更新但是不提交的时候，其他进程也对该行进行更新则需要进行等待，这就是行锁,其他进程更新别的行是不会受影响的。

> 当我们的行锁涉及到索引失效的时候，会触发表锁的行为。

* **表锁**: 我们在编辑表，或者执行修改表的事情了语句的时候，一般都会给表加上表锁，可以避免一些不同步的事情出现，表锁分为两种，一种是读锁，一种是写锁。

```sql
lock table 表名 read(write);  //加锁

unlock tables; //释放锁
```

>读锁会阻塞写，但是不会堵塞读。而写锁则会把读和写都堵塞。

#### 5、表优化

* **读写分离**: 读数据一个表,写数据一个表
* **垂直拆分**: 理解为,将表字段拆成两个表
* **水平拆分**: 理解为,将表数据分成几个表存,一个表存1-1000, 1001-2000这种形式,一般数据库分片(客户端分片),分布式数据库
 
#### 6、连接池

#### 7、优化建议

* 尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁。
* 合理设计索引，尽量缩小锁的范围
* 尽可能较少检索条件，避免间隙锁
* 尽量控制事务大小，减少锁定资源量和时间长度
* 尽可能低级别事务隔离