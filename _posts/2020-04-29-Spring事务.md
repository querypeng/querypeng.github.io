---
layout:     post
title:      Spring事务
subtitle:   Spring事务的知识总结
date:       2020-04-29
author:     pengfeng
header-img: img/shanghai.jpg
catalog: true
tags:
    - java
    - 事务
    - spring
---

# Spring事务

### Spring事务的隔离级别

* **TransactionDefinition.ISOLATION_DEFAULT**: 基于后端数据库默认的事务隔离级别,MySQL采用的是可重复读(REPEATABLE_READ),Oracle采用是读已提交(READ_COMMITTED)<br/>
* **TransactionDefinition.ISOLATION_READ_UNCOMMITTED**: 读未提交,允许读取未提交的数据,可能会出现脏读,幻读,不可重复读<br/>
* **TransactionDefinition.ISOLATION_READ_COMMITTED**: 读已提交,读取已提交的数据,避免脏读,可能幻读,不可重复读<br/>
* **TransactionDefinition.ISOLATION_REPEATABLE_READ**: 可重复读,可以避免脏读,不可重复读,但是可能会幻读<br/>
* **TransactionDefinition.ISOLATION_SERIALIZABLE**: 串行化,最高级别可避免脏读,幻读,可重复读,但是效率低下,猜测可能是快照操作

### Spring事务的传播行为

**支持当前事务的场景**
* **TransactionDefinition.PROPAGATION_REQUIRED**: 当前有一个事务,就加入这个事务,没有事务就创建一个事务。<br/>
* **TransactionDefinition.PROPAGATION_SUPPORTS**: 当前有一个事务,就加入这个事务,没有事务就非事务执行。<br/>
* **TransactionDefinition.PROPAGATION_MANDATORY**: 当前有一个事务,就加入这个事务,没有事务就抛一个异常。<br/>

**不支持当前事务的场景**
* **TransactionDefinition.PROPAGATION_REQUIRES_NEW**: 创建一个新事务,当前存在一个事务就挂起当前事务。<br/>
* **TransactionDefinition.PROPAGATION_NOT_SUPPORTED**: 非事务运行,当前有事务就挂起当前事务。<br/>
* **TransactionDefinition.PROPAGATION_NEVER**: 非事务运行,存在事务就抛异常。<br/>

**其他情况**
* **TransactionDefinition.PROPAGATION_NESTED**: 当前有事务就创建一个事务当做嵌套事务,没有就相当于创建一个事务。

### 使用方式

* 编程式事务<br/>

编程式事务管理使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，spring推荐使用TransactionTemplate。类似下面的代码，注入transactionTemplate后，执行execute方法，方法参数是一个TransactionCallback的匿名实现，TransactionCallbackWithoutResult是一个抽象类，实现了TransactionCallback接口。

> Spring推荐**TransactionTemplate**方式

```java
//在需要使用的类中注入transactionTemplate
@Autowired
private TransactionTemplate transactionTemplate;

//不关心结果的事务执行方式
transactionTemplate.execute(new TransactionCallbackWithoutResult() {
    @Override
    protected void doInTransactionWithoutResult(TransactionStatus status) {
        //TODO db操作
    }
});

//关心结果的事务执行方式
Order order = transactionTemplate.execute(new TransactionCallback<Order>() {
    @Override
    public Order doInTransaction(TransactionStatus status) {
        Order order = doSomething();
        return order;
    }
});
```

> 基于**PlatformTransactionManager**的

```java
@Resource
private PlatformTransactionManager transactionManager;

TransactionTemplate template = new TransactionTemplate(transactionManager);
        template.execute(new TransactionCallbackWithoutResult() {
            @Override
            protected void doInTransactionWithoutResult(TransactionStatus status) {
                xxxxx  //业务代码
        }
```

* 声明式事务
    - 基于xml配置
    - 基于注解

```java
//注解
@Transactional(rollbackFor = Exception.class, propagation = Propagation.NOT_SUPPORTED)
```


