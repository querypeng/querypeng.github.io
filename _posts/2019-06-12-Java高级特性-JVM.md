---
layout:     post
title:      Java高级特性-JVM
subtitle:   JVM介绍
date:       2019-06-12
author:     pengfeng
header-img: img/post-bg-rwd.jpg
catalog: true
tags:
    - java
    - JVM
---

<div>少年不识愁滋味，爱上层楼。爱上层楼。为赋新词强说愁。</div>
<div>而今识尽愁滋味，欲说还休。欲说还休。却道天凉好个秋。</div>



**不多感慨,直接上干货....**

## 1. JVM介绍

下图是JVM内存模型:

![](/img/JVM.jpg)

分为类*装载器*,*内存区域*,*执行引擎*,*本地库接口*,*垃圾收集器*,下面对其一一讲解.

#### 1.1 类装载器

类装载器也叫类加载器,是负责加载类的对象,前期也对此有过详细讲解.请直接点击[类加载器](https://querypeng.github.io/2019/04/18/Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-%E5%8F%8D%E5%B0%84/)
查阅.

#### 1.2 执行引擎

执行引擎通俗一点说就相当于java和javac等命令用来执行操作.

#### 1.3 本地库接口

本地库接口(Java Native Interface),简称*JNI*和C语言有着很深的渊源,当初Java发明初期,C语言横行.当时的人们认为程序语言就只能是C语言,
甚至还有种风气就是不能和C语言交互的语言就是垃圾语言.
Java之父高斯林为了Java能稳定发展不得不趋于C语言的淫威之下,
添加了一部分本地库接口用于调用操作系统中C语言编写的的本地方法库.


*native*关键字是区别本地库接口的关键,一般源码中带有native无具体方法体的方法就是说明调用C语言的本地方法库

线程类中有这样的方法,如下:
![](/img/Thread.jpg)


#### 1.4 runtime data area 运行时数据区

一般情况下,运行时异常均由此抛出


#### 1.5 本地方法栈和程序计数器

我们一般所说的JVM优化是指虚拟机栈,所以这二者不做详细说明.

#### 1.6 方法区

被所有线程共享,我们所说的JVM优化99%堆 1%方法区,方法区主要是放构造方法和接口代码(所有定义方法的信息都定义在方法区)
 静态变量 + 常量 + 类信息 + 运行时常量池 + 实例变量

#### 1.7 栈(stack)

方法进栈执行,并遵循先进后出,后进先出原则.每一栈被叫做栈帧,栈帧保存本地变量,输入参数,输出参数,方法内变量

>栈操作: 记录进出栈操作

>栈帧数据:类文件 方法数据 

Stack Overflow 栈溢出

#### 1.8 堆

堆分为三个区,分别是新生区,养老区(老年代),永久储存区(持久代).下面对每个区做一个详细介绍

##### 1.8.1 新生区

>分为三个部分: *伊甸区(Eden Space)*  *幸存0区(Survivor 0 Space)*  *幸存1区(Survivor 1 Space)*

**伊甸区(Eden Space)**: 创建对象会被加载进伊甸区,在伊甸区满了之后会进行垃圾回收叫做**Minor GC**(小范围回收).

**幸存0区(Survivor 0 Space)** : 第一波垃圾回收未被回收的对象会被转移到幸存0区.

**幸存1区(Survivor 1 Space)** : 第二波垃圾回收未被回收的对象会被转移到幸存1区.

##### 1.8.2 老年代 Tenure Generation Space (养老区) 

顾名思义老年代就是在第一次垃圾回收存活下来的对象,会进入养老区.养老区当然也会进行垃圾回收,而且是大规模垃圾回收叫做**Major GC(FullGC)**,
所谓的OOM,就是堆内存不够用了.可通过jvm参数-Xms -Xmx来调整,一般池对象都在这个区域活跃,比如连接池,线程池.

##### 1.8.3 持久代(永久储存区)

永久存储区(持久代)(Permanent Space) : 是一个常驻内存区域,用于存放JDK自身所携带的Class,Interface的元元素,
也就是说他储存的是运行环境所必须的类信息,不会被垃圾回收,只有在JVM关闭才会释放该内存. 也会内存溢出 也就是说jar包过多. 
maven技术可以管理jar包解决这个问题.

















## 2. 





















