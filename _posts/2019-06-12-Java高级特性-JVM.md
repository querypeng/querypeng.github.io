---
layout:     post
title:      Java高级特性-JVM
subtitle:   JVM介绍
date:       2019-06-12
author:     pengfeng
header-img: img/post-bg-rwd.jpg
catalog: true
tags:
    - java
    - JVM
---


## 一. JVM基础名词介绍

关于内存模型,内存结构这个东西直接贴个链接![什么是Java内存模型](https://www.jianshu.com/p/bf158fbb2432),本次说的是内存结构,不是内存模型.希望大家不要跟我一样步入误区...

下图是**JVM内存结构**:

![](/img/JVM.jpg)

分为类*装载器*,*内存区域*,*执行引擎*,*本地库接口*,*垃圾收集器*,下面对其一一讲解.

### 1.1 类装载器

类装载器也叫类加载器,是负责加载类的对象,前期也对此有过详细讲解.请直接点击[类加载器](https://querypeng.github.io/2019/04/18/Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-%E5%8F%8D%E5%B0%84/)
查阅.

### 1.2 执行引擎

执行引擎通俗一点说就相当于java和javac等命令用来执行操作.

### 1.3 本地库接口

本地库接口(Java Native Interface),简称*JNI*和C语言有着很深的渊源,当初Java发明初期,C语言横行.当时的人们认为程序语言就只能是C语言,
甚至还有种风气就是不能和C语言交互的语言就是垃圾语言.
Java之父高斯林为了Java能稳定发展不得不趋于C语言的淫威之下,
添加了一部分本地库接口用于调用操作系统中C语言编写的的本地方法库.


*native*关键字是区别本地库接口的关键,一般源码中带有native无具体方法体的方法就是说明调用C语言的本地方法库

线程类中有这样的方法,如下:
![](/img/Thread.jpg)


### 1.4 runtime data area 运行时数据区

一般情况下,运行时异常均由此抛出


### 1.5 本地方法栈和程序计数器

我们一般所说的JVM优化是指虚拟机栈,所以这二者不做详细说明.

### 1.6 方法区

方法区和堆一样是各个线程共享内存区域,我们所说的JVM优化99%堆 1%方法区,它用于存储虚拟机加载的:静态变量+常量+ 类信息+ 运行时常量池+实例变量 
虽然JVM规范将方法区描述为堆得一部分逻辑.但他还有一个别名叫做Non-Heap(非堆),目的就是和堆分开,下面的图可以帮助理解

`常量池`: 方法区的一部分 Class文件除了有类的版本,字段,方法,接口等描述信息外,还有一项就是常量池信息,
这部分内容在类加载后放进方法区的运行时常量池中.


### 1.7 栈(stack)

方法进栈执行,并遵循先进后出,后进先出原则.每一栈被叫做栈帧.

>本地变量: 输入参数,输出参数,方法内变量

>栈操作: 记录进出栈操作

>栈帧数据:类文件 方法数据 

Stack Overflow 栈溢出

### 1.8 堆

堆分为三个区,分别是新生代,养老区(老年代),永久储存区(持久代).下面对每个区做一个详细介绍

![](/img/JVM内存.jpg)

#### 1.8.1 年轻代

>分为三个部分: *伊甸区(Eden Space)*  *幸存0区(Survivor 0 Space)*  *幸存1区(Survivor 1 Space)*

**伊甸区(Eden Space)**: 创建对象会被加载进伊甸区,在伊甸区满了之后会进行垃圾回收叫做**Minor GC**(小范围回收).

**幸存0区(Survivor 0 Space)** : 第一波垃圾回收未被回收的对象会被转移到幸存0区.

**幸存1区(Survivor 1 Space)** : 第二波垃圾回收未被回收的对象会被转移到幸存1区.

#### 1.8.2 老年代 Tenure Generation Space (养老区) 

顾名思义老年代就是在15次垃圾回收存活下来的对象,会进入养老区.养老区当然也会进行垃圾回收,而且是大规模垃圾回收叫做**Major GC(FullGC)**,
所谓的OOM,就是堆内存不够用了.可通过jvm参数-Xms -Xmx来调整,一般池对象都在这个区域活跃,比如连接池,线程池.

#### 1.8.3 永久代(永久储存区)

永久存储区(永久代)(Permanent Space) : 是一个常驻内存区域,用于存放JDK自身所携带的Class,Interface的元元素,
也就是说他储存的是运行环境所必须的类信息,不会被垃圾回收,只有在JVM关闭才会释放该内存. 也会内存溢出 也就是说jar包过多. 
maven技术可以管理jar包解决这个问题.

下面贴两张Java7和Java8的图,进一步分析:
![](/img/1.7JVM.jpg)    ![](/img/1.8JVM.jpg)

能看出java7叫永久代 java8叫元空间

`Java6` 堆和方法区是分开的 方法区就是永久代 常量池放在方法区中

`Java7` 方法区放在堆中,将原本放在永久代的字符串常量池移走  永久代就是方法区的落地实现

> -Xms1024m -Xmx1024m -XX:+PrintGCDtails

`Xms`: 初始分配大小,默认为物理内存的1/64 (初始值)

`Xmx`: 最大分配内存,默认为物理内存的1/4  (最大弹性值)


## 二.JVM理论代码验证


### 2.1 验证1/4和1/64

添加JVM启动参数

![](/img/JVM14164.jpg)

本人8G的内存 

>maxMemory 大约2G 足以证明占1/4
 
>totalMemory 123M 大约是1/64


### 2.2 验证堆内存组成

![](/img/堆组成.jpg)
           
jdk1.8测试 能看出 堆内存 = 老年代 + 年轻代,从而证明元空间和堆划分到一起 但是本质上不属于堆内存


### 2.3 验证垃圾回收顺序

![](/img/JVM垃圾回收以及顺序.jpg)
![](/img/JVM控制台.jpg)

能看出年轻代满了继续占用老年代,GC一直在回收垃圾对象


## 三.GC算法

目前GC一共四大算法,分别是: 复制算法,标记清楚算法,标记整理算法,引用计数算法.

### 3.1 引用计数算法

`引用计数`:算法因为无法解决双端引用问题,所以已被淘汰.


### 3.2 复制算法

首先来一句口诀:`复制要交换,谁空谁是to`.掌握此口诀基本算是了解了复制算法

>1个Eden 2个Survivor 比例 8:1:1 

`复制算法`:普通GC(Minor GC)一般发生在新生代,频繁发生此区域的算法是复制算法(copying).对象在伊甸园区(包含Survivor区),即from区,
第一次复制算法会复制到另外的空区域to区,此时这批对象年龄加1,此时这个区域由to区变为from区,前面的对象被复制走后空间被清空变成了to区,这样来回复制15次,
这批对象修成正果进入老年代.通俗来说将内存分为两块,一块储存一块方便转移,因为是全量复制,不会产生内存碎片,浪费一点空间


### 3.3 标记清楚算法

会将垃圾对象进行标记,然后清除,会影响内存连续性,所以会产生内存碎片.



### 3.4 标记整理算法

会标记垃圾对象,然后清除整理,解决了内存碎片化问题,但是会浪费时间性能.

`-XX:MaxTenuringThreshold` JVM参数可来查看算法运行情况,本次不继续探究了,下次有空再更🏃🏃🏃
























